package logger

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// InterfaceMock implements Interface
type InterfaceMock struct {
	t minimock.Tester

	funcDebug          func(format string, args ...interface{})
	inspectFuncDebug   func(format string, args ...interface{})
	afterDebugCounter  uint64
	beforeDebugCounter uint64
	DebugMock          mInterfaceMockDebug

	funcError          func(format string, args ...interface{})
	inspectFuncError   func(format string, args ...interface{})
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mInterfaceMockError

	funcFatal          func(format string, args ...interface{})
	inspectFuncFatal   func(format string, args ...interface{})
	afterFatalCounter  uint64
	beforeFatalCounter uint64
	FatalMock          mInterfaceMockFatal

	funcInfo          func(format string, args ...interface{})
	inspectFuncInfo   func(format string, args ...interface{})
	afterInfoCounter  uint64
	beforeInfoCounter uint64
	InfoMock          mInterfaceMockInfo

	funcPanic          func(format string, args ...interface{})
	inspectFuncPanic   func(format string, args ...interface{})
	afterPanicCounter  uint64
	beforePanicCounter uint64
	PanicMock          mInterfaceMockPanic

	funcPrintf          func(format string, args ...interface{})
	inspectFuncPrintf   func(format string, args ...interface{})
	afterPrintfCounter  uint64
	beforePrintfCounter uint64
	PrintfMock          mInterfaceMockPrintf

	funcWarn          func(format string, args ...interface{})
	inspectFuncWarn   func(format string, args ...interface{})
	afterWarnCounter  uint64
	beforeWarnCounter uint64
	WarnMock          mInterfaceMockWarn

	funcWithFields          func(keyValues Fields) (i1 Interface)
	inspectFuncWithFields   func(keyValues Fields)
	afterWithFieldsCounter  uint64
	beforeWithFieldsCounter uint64
	WithFieldsMock          mInterfaceMockWithFields
}

// NewInterfaceMock returns a mock for Interface
func NewInterfaceMock(t minimock.Tester) *InterfaceMock {
	m := &InterfaceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DebugMock = mInterfaceMockDebug{mock: m}
	m.DebugMock.callArgs = []*InterfaceMockDebugParams{}

	m.ErrorMock = mInterfaceMockError{mock: m}
	m.ErrorMock.callArgs = []*InterfaceMockErrorParams{}

	m.FatalMock = mInterfaceMockFatal{mock: m}
	m.FatalMock.callArgs = []*InterfaceMockFatalParams{}

	m.InfoMock = mInterfaceMockInfo{mock: m}
	m.InfoMock.callArgs = []*InterfaceMockInfoParams{}

	m.PanicMock = mInterfaceMockPanic{mock: m}
	m.PanicMock.callArgs = []*InterfaceMockPanicParams{}

	m.PrintfMock = mInterfaceMockPrintf{mock: m}
	m.PrintfMock.callArgs = []*InterfaceMockPrintfParams{}

	m.WarnMock = mInterfaceMockWarn{mock: m}
	m.WarnMock.callArgs = []*InterfaceMockWarnParams{}

	m.WithFieldsMock = mInterfaceMockWithFields{mock: m}
	m.WithFieldsMock.callArgs = []*InterfaceMockWithFieldsParams{}

	return m
}

type mInterfaceMockDebug struct {
	mock               *InterfaceMock
	defaultExpectation *InterfaceMockDebugExpectation
	expectations       []*InterfaceMockDebugExpectation

	callArgs []*InterfaceMockDebugParams
	mutex    sync.RWMutex
}

// InterfaceMockDebugExpectation specifies expectation struct of the Interface.Debug
type InterfaceMockDebugExpectation struct {
	mock   *InterfaceMock
	params *InterfaceMockDebugParams

	Counter uint64
}

// InterfaceMockDebugParams contains parameters of the Interface.Debug
type InterfaceMockDebugParams struct {
	format string
	args   []interface{}
}

// Expect sets up expected params for Interface.Debug
func (mmDebug *mInterfaceMockDebug) Expect(format string, args ...interface{}) *mInterfaceMockDebug {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("InterfaceMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &InterfaceMockDebugExpectation{}
	}

	mmDebug.defaultExpectation.params = &InterfaceMockDebugParams{format, args}
	for _, e := range mmDebug.expectations {
		if minimock.Equal(e.params, mmDebug.defaultExpectation.params) {
			mmDebug.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDebug.defaultExpectation.params)
		}
	}

	return mmDebug
}

// Inspect accepts an inspector function that has same arguments as the Interface.Debug
func (mmDebug *mInterfaceMockDebug) Inspect(f func(format string, args ...interface{})) *mInterfaceMockDebug {
	if mmDebug.mock.inspectFuncDebug != nil {
		mmDebug.mock.t.Fatalf("Inspect function is already set for InterfaceMock.Debug")
	}

	mmDebug.mock.inspectFuncDebug = f

	return mmDebug
}

// Return sets up results that will be returned by Interface.Debug
func (mmDebug *mInterfaceMockDebug) Return() *InterfaceMock {
	if mmDebug.mock.funcDebug != nil {
		mmDebug.mock.t.Fatalf("InterfaceMock.Debug mock is already set by Set")
	}

	if mmDebug.defaultExpectation == nil {
		mmDebug.defaultExpectation = &InterfaceMockDebugExpectation{mock: mmDebug.mock}
	}

	return mmDebug.mock
}

//Set uses given function f to mock the Interface.Debug method
func (mmDebug *mInterfaceMockDebug) Set(f func(format string, args ...interface{})) *InterfaceMock {
	if mmDebug.defaultExpectation != nil {
		mmDebug.mock.t.Fatalf("Default expectation is already set for the Interface.Debug method")
	}

	if len(mmDebug.expectations) > 0 {
		mmDebug.mock.t.Fatalf("Some expectations are already set for the Interface.Debug method")
	}

	mmDebug.mock.funcDebug = f
	return mmDebug.mock
}

// Debug implements Interface
func (mmDebug *InterfaceMock) Debug(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmDebug.beforeDebugCounter, 1)
	defer mm_atomic.AddUint64(&mmDebug.afterDebugCounter, 1)

	if mmDebug.inspectFuncDebug != nil {
		mmDebug.inspectFuncDebug(format, args...)
	}

	mm_params := &InterfaceMockDebugParams{format, args}

	// Record call args
	mmDebug.DebugMock.mutex.Lock()
	mmDebug.DebugMock.callArgs = append(mmDebug.DebugMock.callArgs, mm_params)
	mmDebug.DebugMock.mutex.Unlock()

	for _, e := range mmDebug.DebugMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDebug.DebugMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDebug.DebugMock.defaultExpectation.Counter, 1)
		mm_want := mmDebug.DebugMock.defaultExpectation.params
		mm_got := InterfaceMockDebugParams{format, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDebug.t.Errorf("InterfaceMock.Debug got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDebug.funcDebug != nil {
		mmDebug.funcDebug(format, args...)
		return
	}
	mmDebug.t.Fatalf("Unexpected call to InterfaceMock.Debug. %v %v", format, args)

}

// DebugAfterCounter returns a count of finished InterfaceMock.Debug invocations
func (mmDebug *InterfaceMock) DebugAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.afterDebugCounter)
}

// DebugBeforeCounter returns a count of InterfaceMock.Debug invocations
func (mmDebug *InterfaceMock) DebugBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDebug.beforeDebugCounter)
}

// Calls returns a list of arguments used in each call to InterfaceMock.Debug.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDebug *mInterfaceMockDebug) Calls() []*InterfaceMockDebugParams {
	mmDebug.mutex.RLock()

	argCopy := make([]*InterfaceMockDebugParams, len(mmDebug.callArgs))
	copy(argCopy, mmDebug.callArgs)

	mmDebug.mutex.RUnlock()

	return argCopy
}

// MinimockDebugDone returns true if the count of the Debug invocations corresponds
// the number of defined expectations
func (m *InterfaceMock) MinimockDebugDone() bool {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		return false
	}
	return true
}

// MinimockDebugInspect logs each unmet expectation
func (m *InterfaceMock) MinimockDebugInspect() {
	for _, e := range m.DebugMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InterfaceMock.Debug with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DebugMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		if m.DebugMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InterfaceMock.Debug")
		} else {
			m.t.Errorf("Expected call to InterfaceMock.Debug with params: %#v", *m.DebugMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDebug != nil && mm_atomic.LoadUint64(&m.afterDebugCounter) < 1 {
		m.t.Error("Expected call to InterfaceMock.Debug")
	}
}

type mInterfaceMockError struct {
	mock               *InterfaceMock
	defaultExpectation *InterfaceMockErrorExpectation
	expectations       []*InterfaceMockErrorExpectation

	callArgs []*InterfaceMockErrorParams
	mutex    sync.RWMutex
}

// InterfaceMockErrorExpectation specifies expectation struct of the Interface.Error
type InterfaceMockErrorExpectation struct {
	mock   *InterfaceMock
	params *InterfaceMockErrorParams

	Counter uint64
}

// InterfaceMockErrorParams contains parameters of the Interface.Error
type InterfaceMockErrorParams struct {
	format string
	args   []interface{}
}

// Expect sets up expected params for Interface.Error
func (mmError *mInterfaceMockError) Expect(format string, args ...interface{}) *mInterfaceMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("InterfaceMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &InterfaceMockErrorExpectation{}
	}

	mmError.defaultExpectation.params = &InterfaceMockErrorParams{format, args}
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the Interface.Error
func (mmError *mInterfaceMockError) Inspect(f func(format string, args ...interface{})) *mInterfaceMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for InterfaceMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by Interface.Error
func (mmError *mInterfaceMockError) Return() *InterfaceMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("InterfaceMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &InterfaceMockErrorExpectation{mock: mmError.mock}
	}

	return mmError.mock
}

//Set uses given function f to mock the Interface.Error method
func (mmError *mInterfaceMockError) Set(f func(format string, args ...interface{})) *InterfaceMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the Interface.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the Interface.Error method")
	}

	mmError.mock.funcError = f
	return mmError.mock
}

// Error implements Interface
func (mmError *InterfaceMock) Error(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(format, args...)
	}

	mm_params := &InterfaceMockErrorParams{format, args}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_got := InterfaceMockErrorParams{format, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("InterfaceMock.Error got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(format, args...)
		return
	}
	mmError.t.Fatalf("Unexpected call to InterfaceMock.Error. %v %v", format, args)

}

// ErrorAfterCounter returns a count of finished InterfaceMock.Error invocations
func (mmError *InterfaceMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of InterfaceMock.Error invocations
func (mmError *InterfaceMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to InterfaceMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mInterfaceMockError) Calls() []*InterfaceMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*InterfaceMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *InterfaceMock) MinimockErrorDone() bool {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorInspect logs each unmet expectation
func (m *InterfaceMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InterfaceMock.Error with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InterfaceMock.Error")
		} else {
			m.t.Errorf("Expected call to InterfaceMock.Error with params: %#v", *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		m.t.Error("Expected call to InterfaceMock.Error")
	}
}

type mInterfaceMockFatal struct {
	mock               *InterfaceMock
	defaultExpectation *InterfaceMockFatalExpectation
	expectations       []*InterfaceMockFatalExpectation

	callArgs []*InterfaceMockFatalParams
	mutex    sync.RWMutex
}

// InterfaceMockFatalExpectation specifies expectation struct of the Interface.Fatal
type InterfaceMockFatalExpectation struct {
	mock   *InterfaceMock
	params *InterfaceMockFatalParams

	Counter uint64
}

// InterfaceMockFatalParams contains parameters of the Interface.Fatal
type InterfaceMockFatalParams struct {
	format string
	args   []interface{}
}

// Expect sets up expected params for Interface.Fatal
func (mmFatal *mInterfaceMockFatal) Expect(format string, args ...interface{}) *mInterfaceMockFatal {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("InterfaceMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &InterfaceMockFatalExpectation{}
	}

	mmFatal.defaultExpectation.params = &InterfaceMockFatalParams{format, args}
	for _, e := range mmFatal.expectations {
		if minimock.Equal(e.params, mmFatal.defaultExpectation.params) {
			mmFatal.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFatal.defaultExpectation.params)
		}
	}

	return mmFatal
}

// Inspect accepts an inspector function that has same arguments as the Interface.Fatal
func (mmFatal *mInterfaceMockFatal) Inspect(f func(format string, args ...interface{})) *mInterfaceMockFatal {
	if mmFatal.mock.inspectFuncFatal != nil {
		mmFatal.mock.t.Fatalf("Inspect function is already set for InterfaceMock.Fatal")
	}

	mmFatal.mock.inspectFuncFatal = f

	return mmFatal
}

// Return sets up results that will be returned by Interface.Fatal
func (mmFatal *mInterfaceMockFatal) Return() *InterfaceMock {
	if mmFatal.mock.funcFatal != nil {
		mmFatal.mock.t.Fatalf("InterfaceMock.Fatal mock is already set by Set")
	}

	if mmFatal.defaultExpectation == nil {
		mmFatal.defaultExpectation = &InterfaceMockFatalExpectation{mock: mmFatal.mock}
	}

	return mmFatal.mock
}

//Set uses given function f to mock the Interface.Fatal method
func (mmFatal *mInterfaceMockFatal) Set(f func(format string, args ...interface{})) *InterfaceMock {
	if mmFatal.defaultExpectation != nil {
		mmFatal.mock.t.Fatalf("Default expectation is already set for the Interface.Fatal method")
	}

	if len(mmFatal.expectations) > 0 {
		mmFatal.mock.t.Fatalf("Some expectations are already set for the Interface.Fatal method")
	}

	mmFatal.mock.funcFatal = f
	return mmFatal.mock
}

// Fatal implements Interface
func (mmFatal *InterfaceMock) Fatal(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmFatal.beforeFatalCounter, 1)
	defer mm_atomic.AddUint64(&mmFatal.afterFatalCounter, 1)

	if mmFatal.inspectFuncFatal != nil {
		mmFatal.inspectFuncFatal(format, args...)
	}

	mm_params := &InterfaceMockFatalParams{format, args}

	// Record call args
	mmFatal.FatalMock.mutex.Lock()
	mmFatal.FatalMock.callArgs = append(mmFatal.FatalMock.callArgs, mm_params)
	mmFatal.FatalMock.mutex.Unlock()

	for _, e := range mmFatal.FatalMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFatal.FatalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFatal.FatalMock.defaultExpectation.Counter, 1)
		mm_want := mmFatal.FatalMock.defaultExpectation.params
		mm_got := InterfaceMockFatalParams{format, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFatal.t.Errorf("InterfaceMock.Fatal got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmFatal.funcFatal != nil {
		mmFatal.funcFatal(format, args...)
		return
	}
	mmFatal.t.Fatalf("Unexpected call to InterfaceMock.Fatal. %v %v", format, args)

}

// FatalAfterCounter returns a count of finished InterfaceMock.Fatal invocations
func (mmFatal *InterfaceMock) FatalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.afterFatalCounter)
}

// FatalBeforeCounter returns a count of InterfaceMock.Fatal invocations
func (mmFatal *InterfaceMock) FatalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFatal.beforeFatalCounter)
}

// Calls returns a list of arguments used in each call to InterfaceMock.Fatal.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFatal *mInterfaceMockFatal) Calls() []*InterfaceMockFatalParams {
	mmFatal.mutex.RLock()

	argCopy := make([]*InterfaceMockFatalParams, len(mmFatal.callArgs))
	copy(argCopy, mmFatal.callArgs)

	mmFatal.mutex.RUnlock()

	return argCopy
}

// MinimockFatalDone returns true if the count of the Fatal invocations corresponds
// the number of defined expectations
func (m *InterfaceMock) MinimockFatalDone() bool {
	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FatalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatal != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		return false
	}
	return true
}

// MinimockFatalInspect logs each unmet expectation
func (m *InterfaceMock) MinimockFatalInspect() {
	for _, e := range m.FatalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InterfaceMock.Fatal with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FatalMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		if m.FatalMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InterfaceMock.Fatal")
		} else {
			m.t.Errorf("Expected call to InterfaceMock.Fatal with params: %#v", *m.FatalMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFatal != nil && mm_atomic.LoadUint64(&m.afterFatalCounter) < 1 {
		m.t.Error("Expected call to InterfaceMock.Fatal")
	}
}

type mInterfaceMockInfo struct {
	mock               *InterfaceMock
	defaultExpectation *InterfaceMockInfoExpectation
	expectations       []*InterfaceMockInfoExpectation

	callArgs []*InterfaceMockInfoParams
	mutex    sync.RWMutex
}

// InterfaceMockInfoExpectation specifies expectation struct of the Interface.Info
type InterfaceMockInfoExpectation struct {
	mock   *InterfaceMock
	params *InterfaceMockInfoParams

	Counter uint64
}

// InterfaceMockInfoParams contains parameters of the Interface.Info
type InterfaceMockInfoParams struct {
	format string
	args   []interface{}
}

// Expect sets up expected params for Interface.Info
func (mmInfo *mInterfaceMockInfo) Expect(format string, args ...interface{}) *mInterfaceMockInfo {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("InterfaceMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &InterfaceMockInfoExpectation{}
	}

	mmInfo.defaultExpectation.params = &InterfaceMockInfoParams{format, args}
	for _, e := range mmInfo.expectations {
		if minimock.Equal(e.params, mmInfo.defaultExpectation.params) {
			mmInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInfo.defaultExpectation.params)
		}
	}

	return mmInfo
}

// Inspect accepts an inspector function that has same arguments as the Interface.Info
func (mmInfo *mInterfaceMockInfo) Inspect(f func(format string, args ...interface{})) *mInterfaceMockInfo {
	if mmInfo.mock.inspectFuncInfo != nil {
		mmInfo.mock.t.Fatalf("Inspect function is already set for InterfaceMock.Info")
	}

	mmInfo.mock.inspectFuncInfo = f

	return mmInfo
}

// Return sets up results that will be returned by Interface.Info
func (mmInfo *mInterfaceMockInfo) Return() *InterfaceMock {
	if mmInfo.mock.funcInfo != nil {
		mmInfo.mock.t.Fatalf("InterfaceMock.Info mock is already set by Set")
	}

	if mmInfo.defaultExpectation == nil {
		mmInfo.defaultExpectation = &InterfaceMockInfoExpectation{mock: mmInfo.mock}
	}

	return mmInfo.mock
}

//Set uses given function f to mock the Interface.Info method
func (mmInfo *mInterfaceMockInfo) Set(f func(format string, args ...interface{})) *InterfaceMock {
	if mmInfo.defaultExpectation != nil {
		mmInfo.mock.t.Fatalf("Default expectation is already set for the Interface.Info method")
	}

	if len(mmInfo.expectations) > 0 {
		mmInfo.mock.t.Fatalf("Some expectations are already set for the Interface.Info method")
	}

	mmInfo.mock.funcInfo = f
	return mmInfo.mock
}

// Info implements Interface
func (mmInfo *InterfaceMock) Info(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmInfo.beforeInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmInfo.afterInfoCounter, 1)

	if mmInfo.inspectFuncInfo != nil {
		mmInfo.inspectFuncInfo(format, args...)
	}

	mm_params := &InterfaceMockInfoParams{format, args}

	// Record call args
	mmInfo.InfoMock.mutex.Lock()
	mmInfo.InfoMock.callArgs = append(mmInfo.InfoMock.callArgs, mm_params)
	mmInfo.InfoMock.mutex.Unlock()

	for _, e := range mmInfo.InfoMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInfo.InfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInfo.InfoMock.defaultExpectation.Counter, 1)
		mm_want := mmInfo.InfoMock.defaultExpectation.params
		mm_got := InterfaceMockInfoParams{format, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInfo.t.Errorf("InterfaceMock.Info got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInfo.funcInfo != nil {
		mmInfo.funcInfo(format, args...)
		return
	}
	mmInfo.t.Fatalf("Unexpected call to InterfaceMock.Info. %v %v", format, args)

}

// InfoAfterCounter returns a count of finished InterfaceMock.Info invocations
func (mmInfo *InterfaceMock) InfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.afterInfoCounter)
}

// InfoBeforeCounter returns a count of InterfaceMock.Info invocations
func (mmInfo *InterfaceMock) InfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInfo.beforeInfoCounter)
}

// Calls returns a list of arguments used in each call to InterfaceMock.Info.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInfo *mInterfaceMockInfo) Calls() []*InterfaceMockInfoParams {
	mmInfo.mutex.RLock()

	argCopy := make([]*InterfaceMockInfoParams, len(mmInfo.callArgs))
	copy(argCopy, mmInfo.callArgs)

	mmInfo.mutex.RUnlock()

	return argCopy
}

// MinimockInfoDone returns true if the count of the Info invocations corresponds
// the number of defined expectations
func (m *InterfaceMock) MinimockInfoDone() bool {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		return false
	}
	return true
}

// MinimockInfoInspect logs each unmet expectation
func (m *InterfaceMock) MinimockInfoInspect() {
	for _, e := range m.InfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InterfaceMock.Info with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InfoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		if m.InfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InterfaceMock.Info")
		} else {
			m.t.Errorf("Expected call to InterfaceMock.Info with params: %#v", *m.InfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInfo != nil && mm_atomic.LoadUint64(&m.afterInfoCounter) < 1 {
		m.t.Error("Expected call to InterfaceMock.Info")
	}
}

type mInterfaceMockPanic struct {
	mock               *InterfaceMock
	defaultExpectation *InterfaceMockPanicExpectation
	expectations       []*InterfaceMockPanicExpectation

	callArgs []*InterfaceMockPanicParams
	mutex    sync.RWMutex
}

// InterfaceMockPanicExpectation specifies expectation struct of the Interface.Panic
type InterfaceMockPanicExpectation struct {
	mock   *InterfaceMock
	params *InterfaceMockPanicParams

	Counter uint64
}

// InterfaceMockPanicParams contains parameters of the Interface.Panic
type InterfaceMockPanicParams struct {
	format string
	args   []interface{}
}

// Expect sets up expected params for Interface.Panic
func (mmPanic *mInterfaceMockPanic) Expect(format string, args ...interface{}) *mInterfaceMockPanic {
	if mmPanic.mock.funcPanic != nil {
		mmPanic.mock.t.Fatalf("InterfaceMock.Panic mock is already set by Set")
	}

	if mmPanic.defaultExpectation == nil {
		mmPanic.defaultExpectation = &InterfaceMockPanicExpectation{}
	}

	mmPanic.defaultExpectation.params = &InterfaceMockPanicParams{format, args}
	for _, e := range mmPanic.expectations {
		if minimock.Equal(e.params, mmPanic.defaultExpectation.params) {
			mmPanic.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPanic.defaultExpectation.params)
		}
	}

	return mmPanic
}

// Inspect accepts an inspector function that has same arguments as the Interface.Panic
func (mmPanic *mInterfaceMockPanic) Inspect(f func(format string, args ...interface{})) *mInterfaceMockPanic {
	if mmPanic.mock.inspectFuncPanic != nil {
		mmPanic.mock.t.Fatalf("Inspect function is already set for InterfaceMock.Panic")
	}

	mmPanic.mock.inspectFuncPanic = f

	return mmPanic
}

// Return sets up results that will be returned by Interface.Panic
func (mmPanic *mInterfaceMockPanic) Return() *InterfaceMock {
	if mmPanic.mock.funcPanic != nil {
		mmPanic.mock.t.Fatalf("InterfaceMock.Panic mock is already set by Set")
	}

	if mmPanic.defaultExpectation == nil {
		mmPanic.defaultExpectation = &InterfaceMockPanicExpectation{mock: mmPanic.mock}
	}

	return mmPanic.mock
}

//Set uses given function f to mock the Interface.Panic method
func (mmPanic *mInterfaceMockPanic) Set(f func(format string, args ...interface{})) *InterfaceMock {
	if mmPanic.defaultExpectation != nil {
		mmPanic.mock.t.Fatalf("Default expectation is already set for the Interface.Panic method")
	}

	if len(mmPanic.expectations) > 0 {
		mmPanic.mock.t.Fatalf("Some expectations are already set for the Interface.Panic method")
	}

	mmPanic.mock.funcPanic = f
	return mmPanic.mock
}

// Panic implements Interface
func (mmPanic *InterfaceMock) Panic(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmPanic.beforePanicCounter, 1)
	defer mm_atomic.AddUint64(&mmPanic.afterPanicCounter, 1)

	if mmPanic.inspectFuncPanic != nil {
		mmPanic.inspectFuncPanic(format, args...)
	}

	mm_params := &InterfaceMockPanicParams{format, args}

	// Record call args
	mmPanic.PanicMock.mutex.Lock()
	mmPanic.PanicMock.callArgs = append(mmPanic.PanicMock.callArgs, mm_params)
	mmPanic.PanicMock.mutex.Unlock()

	for _, e := range mmPanic.PanicMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPanic.PanicMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPanic.PanicMock.defaultExpectation.Counter, 1)
		mm_want := mmPanic.PanicMock.defaultExpectation.params
		mm_got := InterfaceMockPanicParams{format, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPanic.t.Errorf("InterfaceMock.Panic got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPanic.funcPanic != nil {
		mmPanic.funcPanic(format, args...)
		return
	}
	mmPanic.t.Fatalf("Unexpected call to InterfaceMock.Panic. %v %v", format, args)

}

// PanicAfterCounter returns a count of finished InterfaceMock.Panic invocations
func (mmPanic *InterfaceMock) PanicAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPanic.afterPanicCounter)
}

// PanicBeforeCounter returns a count of InterfaceMock.Panic invocations
func (mmPanic *InterfaceMock) PanicBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPanic.beforePanicCounter)
}

// Calls returns a list of arguments used in each call to InterfaceMock.Panic.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPanic *mInterfaceMockPanic) Calls() []*InterfaceMockPanicParams {
	mmPanic.mutex.RLock()

	argCopy := make([]*InterfaceMockPanicParams, len(mmPanic.callArgs))
	copy(argCopy, mmPanic.callArgs)

	mmPanic.mutex.RUnlock()

	return argCopy
}

// MinimockPanicDone returns true if the count of the Panic invocations corresponds
// the number of defined expectations
func (m *InterfaceMock) MinimockPanicDone() bool {
	for _, e := range m.PanicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PanicMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPanicCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPanic != nil && mm_atomic.LoadUint64(&m.afterPanicCounter) < 1 {
		return false
	}
	return true
}

// MinimockPanicInspect logs each unmet expectation
func (m *InterfaceMock) MinimockPanicInspect() {
	for _, e := range m.PanicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InterfaceMock.Panic with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PanicMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPanicCounter) < 1 {
		if m.PanicMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InterfaceMock.Panic")
		} else {
			m.t.Errorf("Expected call to InterfaceMock.Panic with params: %#v", *m.PanicMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPanic != nil && mm_atomic.LoadUint64(&m.afterPanicCounter) < 1 {
		m.t.Error("Expected call to InterfaceMock.Panic")
	}
}

type mInterfaceMockPrintf struct {
	mock               *InterfaceMock
	defaultExpectation *InterfaceMockPrintfExpectation
	expectations       []*InterfaceMockPrintfExpectation

	callArgs []*InterfaceMockPrintfParams
	mutex    sync.RWMutex
}

// InterfaceMockPrintfExpectation specifies expectation struct of the Interface.Printf
type InterfaceMockPrintfExpectation struct {
	mock   *InterfaceMock
	params *InterfaceMockPrintfParams

	Counter uint64
}

// InterfaceMockPrintfParams contains parameters of the Interface.Printf
type InterfaceMockPrintfParams struct {
	format string
	args   []interface{}
}

// Expect sets up expected params for Interface.Printf
func (mmPrintf *mInterfaceMockPrintf) Expect(format string, args ...interface{}) *mInterfaceMockPrintf {
	if mmPrintf.mock.funcPrintf != nil {
		mmPrintf.mock.t.Fatalf("InterfaceMock.Printf mock is already set by Set")
	}

	if mmPrintf.defaultExpectation == nil {
		mmPrintf.defaultExpectation = &InterfaceMockPrintfExpectation{}
	}

	mmPrintf.defaultExpectation.params = &InterfaceMockPrintfParams{format, args}
	for _, e := range mmPrintf.expectations {
		if minimock.Equal(e.params, mmPrintf.defaultExpectation.params) {
			mmPrintf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrintf.defaultExpectation.params)
		}
	}

	return mmPrintf
}

// Inspect accepts an inspector function that has same arguments as the Interface.Printf
func (mmPrintf *mInterfaceMockPrintf) Inspect(f func(format string, args ...interface{})) *mInterfaceMockPrintf {
	if mmPrintf.mock.inspectFuncPrintf != nil {
		mmPrintf.mock.t.Fatalf("Inspect function is already set for InterfaceMock.Printf")
	}

	mmPrintf.mock.inspectFuncPrintf = f

	return mmPrintf
}

// Return sets up results that will be returned by Interface.Printf
func (mmPrintf *mInterfaceMockPrintf) Return() *InterfaceMock {
	if mmPrintf.mock.funcPrintf != nil {
		mmPrintf.mock.t.Fatalf("InterfaceMock.Printf mock is already set by Set")
	}

	if mmPrintf.defaultExpectation == nil {
		mmPrintf.defaultExpectation = &InterfaceMockPrintfExpectation{mock: mmPrintf.mock}
	}

	return mmPrintf.mock
}

//Set uses given function f to mock the Interface.Printf method
func (mmPrintf *mInterfaceMockPrintf) Set(f func(format string, args ...interface{})) *InterfaceMock {
	if mmPrintf.defaultExpectation != nil {
		mmPrintf.mock.t.Fatalf("Default expectation is already set for the Interface.Printf method")
	}

	if len(mmPrintf.expectations) > 0 {
		mmPrintf.mock.t.Fatalf("Some expectations are already set for the Interface.Printf method")
	}

	mmPrintf.mock.funcPrintf = f
	return mmPrintf.mock
}

// Printf implements Interface
func (mmPrintf *InterfaceMock) Printf(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmPrintf.beforePrintfCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintf.afterPrintfCounter, 1)

	if mmPrintf.inspectFuncPrintf != nil {
		mmPrintf.inspectFuncPrintf(format, args...)
	}

	mm_params := &InterfaceMockPrintfParams{format, args}

	// Record call args
	mmPrintf.PrintfMock.mutex.Lock()
	mmPrintf.PrintfMock.callArgs = append(mmPrintf.PrintfMock.callArgs, mm_params)
	mmPrintf.PrintfMock.mutex.Unlock()

	for _, e := range mmPrintf.PrintfMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrintf.PrintfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintf.PrintfMock.defaultExpectation.Counter, 1)
		mm_want := mmPrintf.PrintfMock.defaultExpectation.params
		mm_got := InterfaceMockPrintfParams{format, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrintf.t.Errorf("InterfaceMock.Printf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrintf.funcPrintf != nil {
		mmPrintf.funcPrintf(format, args...)
		return
	}
	mmPrintf.t.Fatalf("Unexpected call to InterfaceMock.Printf. %v %v", format, args)

}

// PrintfAfterCounter returns a count of finished InterfaceMock.Printf invocations
func (mmPrintf *InterfaceMock) PrintfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintf.afterPrintfCounter)
}

// PrintfBeforeCounter returns a count of InterfaceMock.Printf invocations
func (mmPrintf *InterfaceMock) PrintfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintf.beforePrintfCounter)
}

// Calls returns a list of arguments used in each call to InterfaceMock.Printf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrintf *mInterfaceMockPrintf) Calls() []*InterfaceMockPrintfParams {
	mmPrintf.mutex.RLock()

	argCopy := make([]*InterfaceMockPrintfParams, len(mmPrintf.callArgs))
	copy(argCopy, mmPrintf.callArgs)

	mmPrintf.mutex.RUnlock()

	return argCopy
}

// MinimockPrintfDone returns true if the count of the Printf invocations corresponds
// the number of defined expectations
func (m *InterfaceMock) MinimockPrintfDone() bool {
	for _, e := range m.PrintfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintf != nil && mm_atomic.LoadUint64(&m.afterPrintfCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrintfInspect logs each unmet expectation
func (m *InterfaceMock) MinimockPrintfInspect() {
	for _, e := range m.PrintfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InterfaceMock.Printf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintfCounter) < 1 {
		if m.PrintfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InterfaceMock.Printf")
		} else {
			m.t.Errorf("Expected call to InterfaceMock.Printf with params: %#v", *m.PrintfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintf != nil && mm_atomic.LoadUint64(&m.afterPrintfCounter) < 1 {
		m.t.Error("Expected call to InterfaceMock.Printf")
	}
}

type mInterfaceMockWarn struct {
	mock               *InterfaceMock
	defaultExpectation *InterfaceMockWarnExpectation
	expectations       []*InterfaceMockWarnExpectation

	callArgs []*InterfaceMockWarnParams
	mutex    sync.RWMutex
}

// InterfaceMockWarnExpectation specifies expectation struct of the Interface.Warn
type InterfaceMockWarnExpectation struct {
	mock   *InterfaceMock
	params *InterfaceMockWarnParams

	Counter uint64
}

// InterfaceMockWarnParams contains parameters of the Interface.Warn
type InterfaceMockWarnParams struct {
	format string
	args   []interface{}
}

// Expect sets up expected params for Interface.Warn
func (mmWarn *mInterfaceMockWarn) Expect(format string, args ...interface{}) *mInterfaceMockWarn {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("InterfaceMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &InterfaceMockWarnExpectation{}
	}

	mmWarn.defaultExpectation.params = &InterfaceMockWarnParams{format, args}
	for _, e := range mmWarn.expectations {
		if minimock.Equal(e.params, mmWarn.defaultExpectation.params) {
			mmWarn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarn.defaultExpectation.params)
		}
	}

	return mmWarn
}

// Inspect accepts an inspector function that has same arguments as the Interface.Warn
func (mmWarn *mInterfaceMockWarn) Inspect(f func(format string, args ...interface{})) *mInterfaceMockWarn {
	if mmWarn.mock.inspectFuncWarn != nil {
		mmWarn.mock.t.Fatalf("Inspect function is already set for InterfaceMock.Warn")
	}

	mmWarn.mock.inspectFuncWarn = f

	return mmWarn
}

// Return sets up results that will be returned by Interface.Warn
func (mmWarn *mInterfaceMockWarn) Return() *InterfaceMock {
	if mmWarn.mock.funcWarn != nil {
		mmWarn.mock.t.Fatalf("InterfaceMock.Warn mock is already set by Set")
	}

	if mmWarn.defaultExpectation == nil {
		mmWarn.defaultExpectation = &InterfaceMockWarnExpectation{mock: mmWarn.mock}
	}

	return mmWarn.mock
}

//Set uses given function f to mock the Interface.Warn method
func (mmWarn *mInterfaceMockWarn) Set(f func(format string, args ...interface{})) *InterfaceMock {
	if mmWarn.defaultExpectation != nil {
		mmWarn.mock.t.Fatalf("Default expectation is already set for the Interface.Warn method")
	}

	if len(mmWarn.expectations) > 0 {
		mmWarn.mock.t.Fatalf("Some expectations are already set for the Interface.Warn method")
	}

	mmWarn.mock.funcWarn = f
	return mmWarn.mock
}

// Warn implements Interface
func (mmWarn *InterfaceMock) Warn(format string, args ...interface{}) {
	mm_atomic.AddUint64(&mmWarn.beforeWarnCounter, 1)
	defer mm_atomic.AddUint64(&mmWarn.afterWarnCounter, 1)

	if mmWarn.inspectFuncWarn != nil {
		mmWarn.inspectFuncWarn(format, args...)
	}

	mm_params := &InterfaceMockWarnParams{format, args}

	// Record call args
	mmWarn.WarnMock.mutex.Lock()
	mmWarn.WarnMock.callArgs = append(mmWarn.WarnMock.callArgs, mm_params)
	mmWarn.WarnMock.mutex.Unlock()

	for _, e := range mmWarn.WarnMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarn.WarnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarn.WarnMock.defaultExpectation.Counter, 1)
		mm_want := mmWarn.WarnMock.defaultExpectation.params
		mm_got := InterfaceMockWarnParams{format, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarn.t.Errorf("InterfaceMock.Warn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarn.funcWarn != nil {
		mmWarn.funcWarn(format, args...)
		return
	}
	mmWarn.t.Fatalf("Unexpected call to InterfaceMock.Warn. %v %v", format, args)

}

// WarnAfterCounter returns a count of finished InterfaceMock.Warn invocations
func (mmWarn *InterfaceMock) WarnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.afterWarnCounter)
}

// WarnBeforeCounter returns a count of InterfaceMock.Warn invocations
func (mmWarn *InterfaceMock) WarnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarn.beforeWarnCounter)
}

// Calls returns a list of arguments used in each call to InterfaceMock.Warn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarn *mInterfaceMockWarn) Calls() []*InterfaceMockWarnParams {
	mmWarn.mutex.RLock()

	argCopy := make([]*InterfaceMockWarnParams, len(mmWarn.callArgs))
	copy(argCopy, mmWarn.callArgs)

	mmWarn.mutex.RUnlock()

	return argCopy
}

// MinimockWarnDone returns true if the count of the Warn invocations corresponds
// the number of defined expectations
func (m *InterfaceMock) MinimockWarnDone() bool {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		return false
	}
	return true
}

// MinimockWarnInspect logs each unmet expectation
func (m *InterfaceMock) MinimockWarnInspect() {
	for _, e := range m.WarnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InterfaceMock.Warn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		if m.WarnMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InterfaceMock.Warn")
		} else {
			m.t.Errorf("Expected call to InterfaceMock.Warn with params: %#v", *m.WarnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarn != nil && mm_atomic.LoadUint64(&m.afterWarnCounter) < 1 {
		m.t.Error("Expected call to InterfaceMock.Warn")
	}
}

type mInterfaceMockWithFields struct {
	mock               *InterfaceMock
	defaultExpectation *InterfaceMockWithFieldsExpectation
	expectations       []*InterfaceMockWithFieldsExpectation

	callArgs []*InterfaceMockWithFieldsParams
	mutex    sync.RWMutex
}

// InterfaceMockWithFieldsExpectation specifies expectation struct of the Interface.WithFields
type InterfaceMockWithFieldsExpectation struct {
	mock    *InterfaceMock
	params  *InterfaceMockWithFieldsParams
	results *InterfaceMockWithFieldsResults
	Counter uint64
}

// InterfaceMockWithFieldsParams contains parameters of the Interface.WithFields
type InterfaceMockWithFieldsParams struct {
	keyValues Fields
}

// InterfaceMockWithFieldsResults contains results of the Interface.WithFields
type InterfaceMockWithFieldsResults struct {
	i1 Interface
}

// Expect sets up expected params for Interface.WithFields
func (mmWithFields *mInterfaceMockWithFields) Expect(keyValues Fields) *mInterfaceMockWithFields {
	if mmWithFields.mock.funcWithFields != nil {
		mmWithFields.mock.t.Fatalf("InterfaceMock.WithFields mock is already set by Set")
	}

	if mmWithFields.defaultExpectation == nil {
		mmWithFields.defaultExpectation = &InterfaceMockWithFieldsExpectation{}
	}

	mmWithFields.defaultExpectation.params = &InterfaceMockWithFieldsParams{keyValues}
	for _, e := range mmWithFields.expectations {
		if minimock.Equal(e.params, mmWithFields.defaultExpectation.params) {
			mmWithFields.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithFields.defaultExpectation.params)
		}
	}

	return mmWithFields
}

// Inspect accepts an inspector function that has same arguments as the Interface.WithFields
func (mmWithFields *mInterfaceMockWithFields) Inspect(f func(keyValues Fields)) *mInterfaceMockWithFields {
	if mmWithFields.mock.inspectFuncWithFields != nil {
		mmWithFields.mock.t.Fatalf("Inspect function is already set for InterfaceMock.WithFields")
	}

	mmWithFields.mock.inspectFuncWithFields = f

	return mmWithFields
}

// Return sets up results that will be returned by Interface.WithFields
func (mmWithFields *mInterfaceMockWithFields) Return(i1 Interface) *InterfaceMock {
	if mmWithFields.mock.funcWithFields != nil {
		mmWithFields.mock.t.Fatalf("InterfaceMock.WithFields mock is already set by Set")
	}

	if mmWithFields.defaultExpectation == nil {
		mmWithFields.defaultExpectation = &InterfaceMockWithFieldsExpectation{mock: mmWithFields.mock}
	}
	mmWithFields.defaultExpectation.results = &InterfaceMockWithFieldsResults{i1}
	return mmWithFields.mock
}

//Set uses given function f to mock the Interface.WithFields method
func (mmWithFields *mInterfaceMockWithFields) Set(f func(keyValues Fields) (i1 Interface)) *InterfaceMock {
	if mmWithFields.defaultExpectation != nil {
		mmWithFields.mock.t.Fatalf("Default expectation is already set for the Interface.WithFields method")
	}

	if len(mmWithFields.expectations) > 0 {
		mmWithFields.mock.t.Fatalf("Some expectations are already set for the Interface.WithFields method")
	}

	mmWithFields.mock.funcWithFields = f
	return mmWithFields.mock
}

// When sets expectation for the Interface.WithFields which will trigger the result defined by the following
// Then helper
func (mmWithFields *mInterfaceMockWithFields) When(keyValues Fields) *InterfaceMockWithFieldsExpectation {
	if mmWithFields.mock.funcWithFields != nil {
		mmWithFields.mock.t.Fatalf("InterfaceMock.WithFields mock is already set by Set")
	}

	expectation := &InterfaceMockWithFieldsExpectation{
		mock:   mmWithFields.mock,
		params: &InterfaceMockWithFieldsParams{keyValues},
	}
	mmWithFields.expectations = append(mmWithFields.expectations, expectation)
	return expectation
}

// Then sets up Interface.WithFields return parameters for the expectation previously defined by the When method
func (e *InterfaceMockWithFieldsExpectation) Then(i1 Interface) *InterfaceMock {
	e.results = &InterfaceMockWithFieldsResults{i1}
	return e.mock
}

// WithFields implements Interface
func (mmWithFields *InterfaceMock) WithFields(keyValues Fields) (i1 Interface) {
	mm_atomic.AddUint64(&mmWithFields.beforeWithFieldsCounter, 1)
	defer mm_atomic.AddUint64(&mmWithFields.afterWithFieldsCounter, 1)

	if mmWithFields.inspectFuncWithFields != nil {
		mmWithFields.inspectFuncWithFields(keyValues)
	}

	mm_params := &InterfaceMockWithFieldsParams{keyValues}

	// Record call args
	mmWithFields.WithFieldsMock.mutex.Lock()
	mmWithFields.WithFieldsMock.callArgs = append(mmWithFields.WithFieldsMock.callArgs, mm_params)
	mmWithFields.WithFieldsMock.mutex.Unlock()

	for _, e := range mmWithFields.WithFieldsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1
		}
	}

	if mmWithFields.WithFieldsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithFields.WithFieldsMock.defaultExpectation.Counter, 1)
		mm_want := mmWithFields.WithFieldsMock.defaultExpectation.params
		mm_got := InterfaceMockWithFieldsParams{keyValues}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithFields.t.Errorf("InterfaceMock.WithFields got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithFields.WithFieldsMock.defaultExpectation.results
		if mm_results == nil {
			mmWithFields.t.Fatal("No results are set for the InterfaceMock.WithFields")
		}
		return (*mm_results).i1
	}
	if mmWithFields.funcWithFields != nil {
		return mmWithFields.funcWithFields(keyValues)
	}
	mmWithFields.t.Fatalf("Unexpected call to InterfaceMock.WithFields. %v", keyValues)
	return
}

// WithFieldsAfterCounter returns a count of finished InterfaceMock.WithFields invocations
func (mmWithFields *InterfaceMock) WithFieldsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithFields.afterWithFieldsCounter)
}

// WithFieldsBeforeCounter returns a count of InterfaceMock.WithFields invocations
func (mmWithFields *InterfaceMock) WithFieldsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithFields.beforeWithFieldsCounter)
}

// Calls returns a list of arguments used in each call to InterfaceMock.WithFields.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithFields *mInterfaceMockWithFields) Calls() []*InterfaceMockWithFieldsParams {
	mmWithFields.mutex.RLock()

	argCopy := make([]*InterfaceMockWithFieldsParams, len(mmWithFields.callArgs))
	copy(argCopy, mmWithFields.callArgs)

	mmWithFields.mutex.RUnlock()

	return argCopy
}

// MinimockWithFieldsDone returns true if the count of the WithFields invocations corresponds
// the number of defined expectations
func (m *InterfaceMock) MinimockWithFieldsDone() bool {
	for _, e := range m.WithFieldsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFieldsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFieldsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithFields != nil && mm_atomic.LoadUint64(&m.afterWithFieldsCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithFieldsInspect logs each unmet expectation
func (m *InterfaceMock) MinimockWithFieldsInspect() {
	for _, e := range m.WithFieldsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to InterfaceMock.WithFields with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithFieldsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithFieldsCounter) < 1 {
		if m.WithFieldsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to InterfaceMock.WithFields")
		} else {
			m.t.Errorf("Expected call to InterfaceMock.WithFields with params: %#v", *m.WithFieldsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithFields != nil && mm_atomic.LoadUint64(&m.afterWithFieldsCounter) < 1 {
		m.t.Error("Expected call to InterfaceMock.WithFields")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *InterfaceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDebugInspect()

		m.MinimockErrorInspect()

		m.MinimockFatalInspect()

		m.MinimockInfoInspect()

		m.MinimockPanicInspect()

		m.MinimockPrintfInspect()

		m.MinimockWarnInspect()

		m.MinimockWithFieldsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *InterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *InterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDebugDone() &&
		m.MinimockErrorDone() &&
		m.MinimockFatalDone() &&
		m.MinimockInfoDone() &&
		m.MinimockPanicDone() &&
		m.MinimockPrintfDone() &&
		m.MinimockWarnDone() &&
		m.MinimockWithFieldsDone()
}
